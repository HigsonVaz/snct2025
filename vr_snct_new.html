<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ambiente A-Frame VR - Popup no Clique</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <style>
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; }
        a-scene { width: 100vw; height: 100vh; display: block; }
        #popup-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
        .popup {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #00ff88;
            max-width: 280px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            pointer-events: auto;
            display: none;
        }
        .popup-title { font-weight: bold; margin-bottom: 8px; color: #00ff88; font-size: 16px; }
        .popup-desc { line-height: 1.4; }
        .popup-close {
            position: absolute;
            top: 5px;
            right: 10px;
            color: #ff4444;
            font-weight: bold;
            cursor: pointer;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="popup-container"></div>

    <a-scene 
        cursor="rayOrigin: mouse; fuse: false"
        raycaster="objects: .interactive"
        embedded
        loading-screen="enabled: false">

        <a-entity id="rig" movement-controls position="0 1.6 0">
            <a-entity camera look-controls position="0 0 0" wasd-controls="fly: true">
                <a-cursor 
                    id="cursor"
                    raycaster="objects: .interactive"
                    animation__click="property: scale; from: 0.1 0.1 0.1; to: 1 1 1; startEvents: click"
                    animation__fusing="property: scale; from: 1 1 1; to: 0.1 0.1 0.1; startEvents: fusing; dur: 1500"
                    fuse="true"
                    fuse-timeout="500">
                </a-cursor>
            </a-entity>
        </a-entity>

        <a-sky color="#87CEEB"></a-sky>

        <a-plane position="0 0 0" rotation="-90 0 0" width="30" height="30" color="#7CFC00" shadow="receive: true"></a-plane>

        <a-box class="interactive" position="-4 1.5 -5" width="1.5" height="1.5" depth="1.5" color="#FF4444" shadow="cast: true"
               data-title="Cubo Vermelho" data-description="Sólido e estável, representa força e durabilidade."></a-box>

        <a-sphere class="interactive" position="0 1.5 -5" radius="1" color="#44FF44" shadow="cast: true"
                  data-title="Esfera Verde" data-description="Forma perfeita sem arestas, simboliza harmonia."></a-sphere>

        <a-cylinder class="interactive" position="4 1.5 -5" radius="0.8" height="2" color="#4444FF" shadow="cast: true"
                    data-title="Cilindro Azul" data-description="Combina retidão com suavidade."></a-cylinder>

        <a-cone class="interactive" position="-3 1 -7" radius-bottom="1" height="2" color="#FFFF44" shadow="cast: true"
                data-title="Cone Amarelo" data-description="Representa direção e crescimento."></a-cone>

        <!-- Substituí a-pyramid (inconsistente) por a-entity geometry -->
        <a-entity class="interactive" position="3 1 -7" shadow="cast: true"
                  geometry="primitive: box; width: 1.5; height: 2; depth: 1.5"
                  material="color: #FF8844"
                  data-title="Pirâmide Laranja"
                  data-description="Estrutura que representa sabedoria e estabilidade."></a-entity>

        <a-torus class="interactive" position="0 2 -8" arc="360" radius="1.2" radius-tubular="0.2" color="#FFD700" shadow="cast: true"
                 data-title="Anel Dourado" data-description="Símbolo de eternidade e ciclos infinitos."></a-torus>

        <a-entity light="type: ambient; color: #888; intensity: 0.6"></a-entity>
        <a-entity light="type: directional; color: #FFF; intensity: 0.8" position="-5 8 5"></a-entity>
        <a-entity light="type: point; color: #FFF; intensity: 0.5" position="0 5 0"></a-entity>

    </a-scene>

    <script>
    AFRAME.registerComponent('object-interaction', {
        init: function() {
            this.el.addEventListener('click', this.showPopup.bind(this));
            this.el.addEventListener('mouseenter', this.highlightObject.bind(this));
            this.el.addEventListener('mouseleave', this.unhighlightObject.bind(this));
        },

        highlightObject: function() {
            this.el.setAttribute('animation__hover', {
                property: 'scale',
                to: '1.15 1.15 1.15',
                dur: 300,
                easing: 'easeOutElastic'
            });
        },

        unhighlightObject: function() {
            this.el.setAttribute('animation__hover_out', {
                property: 'scale',
                to: '1 1 1',
                dur: 300,
                easing: 'easeOutElastic'
            });
        },

        showPopup: function(evt) {
            this.removeExistingPopup();

            const title = this.el.getAttribute('data-title');
            const description = this.el.getAttribute('data-description');

            // obter ponto do intersection ou fallback para posição do objeto
            let worldPoint = null;
            if (evt && evt.detail && evt.detail.intersection && evt.detail.intersection.point) {
                worldPoint = evt.detail.intersection.point;
            } else if (this.el.object3D) {
                // usa a posição mundial do objeto como fallback
                const v = new AFRAME.THREE.Vector3();
                this.el.object3D.getWorldPosition(v);
                worldPoint = v;
            }

            if (!title || !description || !worldPoint) { return; }

            const screenPoint = this.worldToScreen(worldPoint);
            this.createPopup(title, description, screenPoint.x, screenPoint.y);
        },

        worldToScreen: function(worldPos) {
            const cameraEl = document.querySelector('[camera]');
            const cameraObj = cameraEl && cameraEl.getObject3D && cameraEl.getObject3D('camera');
            const three = AFRAME.THREE;

            // fallback para centro de tela se não houver câmera
            if (!cameraObj) {
                return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            }

            const vector = new three.Vector3(worldPos.x, worldPos.y, worldPos.z);
            vector.project(cameraObj);

            return {
                x: (vector.x * 0.5 + 0.5) * window.innerWidth,
                y: -(vector.y * 0.5 - 0.5) * window.innerHeight
            };
        },

        createPopup: function(title, description, x, y) {
            const popupContainer = document.getElementById('popup-container');

            const popup = document.createElement('div');
            popup.className = 'popup';
            popup.style.display = 'block';
            popup.innerHTML = `
                <div class="popup-close" role="button" title="Fechar">×</div>
                <div class="popup-title">${title}</div>
                <div class="popup-desc">${description}</div>
            `;

            // pointer events enable somente para o popup
            popupContainer.appendChild(popup);

            // posiciona depois que está no DOM para ler offsetHeight corretamente
            this.positionPopup(popup, x, y);

            // fechar ao clicar no X
            popup.querySelector('.popup-close').addEventListener('click', function() {
                if (popup.parentElement) popup.parentElement.removeChild(popup);
            });

            // auto-remove depois de 8s
            setTimeout(() => {
                if (popup.parentElement) popup.parentElement.removeChild(popup);
            }, 8000);
        },

        positionPopup: function(popup, x, y) {
            const margin = 20;
            const popupWidth = 280;
            const popupHeight = popup.offsetHeight || 120; // fallback

            let finalX = x;
            let finalY = y;

            if (finalX + popupWidth > window.innerWidth - margin) {
                finalX = window.innerWidth - popupWidth - margin;
            }
            if (finalX < margin) {
                finalX = margin;
            }
            if (finalY + popupHeight > window.innerHeight - margin) {
                finalY = window.innerHeight - popupHeight - margin;
            }
            if (finalY < margin) {
                finalY = margin;
            }

            popup.style.left = finalX + 'px';
            popup.style.top = finalY + 'px';
        },

        removeExistingPopup: function() {
            const popupContainer = document.getElementById('popup-container');
            const existing = popupContainer.querySelectorAll('.popup');
            existing.forEach(p => p.parentElement && p.parentElement.removeChild(p));
        }
    });

    AFRAME.registerComponent('movement-controls', {
        init: function() {
            if (/Android|iPhone|iPad/i.test(navigator.userAgent)) {
                this.setupMobileOptimizations();
            }
        },
        setupMobileOptimizations: function() {
            const scene = this.el.sceneEl;
            if (scene) scene.setAttribute('renderer', 'antialias: false; colorManagement: true');
        }
    });

    document.addEventListener('DOMContentLoaded', function() {
        const interactiveObjects = document.querySelectorAll('.interactive');
        interactiveObjects.forEach(obj => {
            obj.setAttribute('object-interaction', '');
        });

        document.addEventListener('click', function(evt) {
            if (!evt.target.closest('.popup') && !evt.target.closest('.interactive')) {
                const popupContainer = document.getElementById('popup-container');
                const popups = popupContainer.querySelectorAll('.popup');
                popups.forEach(p => { if (p.parentElement) p.parentElement.removeChild(p); });
            }
        });

        document.addEventListener('touchend', function(evt) {
            if (!evt.target.closest('.popup') && !evt.target.closest('.interactive')) {
                const popupContainer = document.getElementById('popup-container');
                const popups = popupContainer.querySelectorAll('.popup');
                popups.forEach(p => { if (p.parentElement) p.parentElement.removeChild(p); });
            }
        });
    });
    </script>
</body>
</html>
